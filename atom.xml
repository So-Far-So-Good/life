<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Freelemon's open world]]></title>
  <subtitle><![CDATA[Write, Code, Share, Learn]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hongbinzuo.github.io/"/>
  <updated>2014-12-09T11:11:35.410Z</updated>
  <id>http://hongbinzuo.github.io/</id>
  
  <author>
    <name><![CDATA[Hongbin Zuo]]></name>
    <email><![CDATA[zuohongbin@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java performance tips]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/09/Java-performance-tips/"/>
    <id>http://hongbinzuo.github.io/2014/12/09/Java-performance-tips/</id>
    <published>2014-12-09T06:51:26.000Z</published>
    <updated>2014-12-09T06:55:12.000Z</updated>
    <content type="html"><![CDATA[<p>一些有助于改善性能的小技巧</p>
<ol>
<li>慎用异常</li>
<li>使用局部变量</li>
<li>位运算代替乘除法</li>
<li>替换switch</li>
<li>一维数组代替二维数组</li>
<li>提取表达式</li>
<li>展开循环</li>
<li>布尔运算代替位运算</li>
<li>使用arrayCopy()</li>
<li>使用Buffer进行I/O操作</li>
<li>使用clone()代替new</li>
<li>静态方法替代实例方法</li>
</ol>
]]></content>
    
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NIO Buffer]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/09/NIO-Buffer/"/>
    <id>http://hongbinzuo.github.io/2014/12/09/NIO-Buffer/</id>
    <published>2014-12-09T04:02:25.000Z</published>
    <updated>2014-12-09T11:08:46.000Z</updated>
    <content type="html"><![CDATA[<p>简要记录一下Buffer对象的基本原理和操作。</p>
<h3 id="重要参数">重要参数</h3>
<p>Buffer中有三个重要的参数，下面的表格描述了它们的作用和区别：</p>
<p><img alt="Buffer的参数表" src="/img/buffer.png" style="width: 800px;"></p>
<a id="more"></a>

<p>下面的实例可以更好地帮助理解：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class <span class="type">TestBuffer</span> {</div><div class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) {</div><div class="line">        <span class="type">ByteBuffer</span> b = <span class="type">ByteBuffer</span>.allocate(<span class="number">15</span>);</div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"After allocation done: \t"</span>);</div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.printf(<span class="string">"limit=%s, capacity=%d, position=%d\n"</span>, b.limit(), b.capacity(), b.position());</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) {</div><div class="line">            b.put((byte)i);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"After saving 10 bytes: \t"</span>);</div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.printf(<span class="string">"limit=%s, capacity=%d, position=%d\n"</span>, b.limit(), b.capacity(), b.position());</div><div class="line"></div><div class="line">        b.flip();</div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"After flip():\t\t\t"</span>);</div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.printf(<span class="string">"limit=%s, capacity=%d, position=%d\n"</span>, b.limit(), b.capacity(), b.position());</div><div class="line"></div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Reading buffer: \t\t"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</div><div class="line">            <span class="type">System</span>.<span class="keyword">out</span>.print(b.get());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"\nAfter reading 5 bytes: \t"</span>);</div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.printf(<span class="string">"limit=%s, capacity=%d, position=%d\n"</span>, b.limit(), b.capacity(), b.position());</div><div class="line"></div><div class="line"></div><div class="line">        b.flip();</div><div class="line"></div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"After flip(): \t\t\t"</span>);</div><div class="line">        <span class="type">System</span>.<span class="keyword">out</span>.printf(<span class="string">"limit=%2s, capacity=%d, position=%d\n"</span>, b.limit(), b.capacity(), b.position());</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">After allocation done:  <span class="variable">limit=</span><span class="number">15</span>, <span class="variable">capacity=</span><span class="number">15</span>, <span class="variable">position=</span><span class="number">0</span></div><div class="line">After saving <span class="number">10</span> bytes:  <span class="variable">limit=</span><span class="number">15</span>, <span class="variable">capacity=</span><span class="number">15</span>, <span class="variable">position=</span><span class="number">10</span></div><div class="line">After flip():           <span class="variable">limit=</span><span class="number">10</span>, <span class="variable">capacity=</span><span class="number">15</span>, <span class="variable">position=</span><span class="number">0</span></div><div class="line">Reading buffer:         <span class="number">01234</span></div><div class="line">After reading <span class="number">5</span> bytes:  <span class="variable">limit=</span><span class="number">10</span>, <span class="variable">capacity=</span><span class="number">15</span>, <span class="variable">position=</span><span class="number">5</span></div><div class="line">After flip():           <span class="variable">limit=</span> <span class="number">5</span>, <span class="variable">capacity=</span><span class="number">15</span>, <span class="variable">position=</span><span class="number">0</span></div></pre></td></tr></table></figure>

<h3 id="基本操作">基本操作</h3>
<p>Buffer相关的操作有：</p>
<ol>
<li>Buffer创建<ul>
<li>allocate</li>
<li>wrap</li>
</ul>
</li>
<li>重置和清空缓冲区<ul>
<li>rewind</li>
<li>clear</li>
<li>flip</li>
</ul>
</li>
<li>读写缓冲区<ul>
<li>get</li>
<li>put</li>
</ul>
</li>
<li>标志缓冲区<ul>
<li>mark</li>
<li>reset</li>
</ul>
</li>
<li>复制缓冲区<ul>
<li>duplicate</li>
</ul>
</li>
<li>缓冲区分片<ul>
<li>slice</li>
</ul>
</li>
<li>只读缓冲区<ul>
<li>asReadOnlyBuffer</li>
</ul>
</li>
<li>文件映射到内存<ul>
<li>MappedByteBuffer</li>
</ul>
</li>
<li>处理结构化数据<ul>
<li>ScatteringByteChannel</li>
<li>GatheringByteChannel</li>
</ul>
</li>
</ol>
<p>因为内容较多，这里只记录一个大纲，以后需要的时候方便检索。</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="http://ifeve.com/buffers/" target="_blank" rel="external">并发编程网Java NIO教程Buffer部分</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>简要记录一下Buffer对象的基本原理和操作。</p>
<h3 id="重要参数">重要参数</h3>
<p>Buffer中有三个重要的参数，下面的表格描述了它们的作用和区别：</p>
<p><img alt="Buffer的参数表" src="/img/buffer.png" style="width: 800px;"></p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="NIO" scheme="http://hongbinzuo.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NIO basics]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/09/NIO-basics/"/>
    <id>http://hongbinzuo.github.io/2014/12/09/NIO-basics/</id>
    <published>2014-12-09T02:44:02.000Z</published>
    <updated>2014-12-09T03:54:05.000Z</updated>
    <content type="html"><![CDATA[<p>NIO是在JDK1.4引入的，代表New IO，具有以下特性：</p>
<ul>
<li>为所有的原始类型提供缓冲（Buffer）支持</li>
<li>使用Java.nio.charset.Charset作为字符集编解码解决方案</li>
<li>增加通道（Channel）对象，作为新的原始I/O抽象</li>
<li>支持锁和内存映射文件的文件访问接口</li>
<li>提供了基于Selector的异步网络IO</li>
</ul>
<a id="more"></a>

<p>与流式的IO不同，NIO是基于块（Block）的，它以块为基本单位处理数据。在NIO中，最为重要的两个组件是缓冲Buffer和通道Channel。缓冲是一块连续的内存块，是NIO读写数据的中转地。通道表示缓冲数据的源头或目的地，它用于向缓冲读取或者写入数据，是访问缓冲的接口。</p>
<p>下面用一个简单的实例来看一下NIO的基本用法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> FileCopy {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            FileCopy.nioCopyFile(<span class="string">"test.txt"</span>, <span class="string">"testcp.txt"</span>);</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            e.printStackTrace();            }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioCopyFile</span>(String resource, String destination) throws IOException {</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(resource);</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destination);</div><div class="line">        FileChannel readChannel = fis.getChannel();</div><div class="line">        FileChannel writeChannel = fos.getChannel();</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</div><div class="line">            buffer.clear();</div><div class="line">            <span class="keyword">int</span> len = readChannel.read(buffer);</div><div class="line">            <span class="keyword">if</span> ( len == -<span class="number">1</span> )</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            buffer.flip();</div><div class="line">            writeChannel.write(buffer);</div><div class="line">        }</div><div class="line"></div><div class="line">        readChannel.close();</div><div class="line">        writeChannel.close();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实例中需要理解的几个点：</p>
<ul>
<li>本例实现了文件拷贝功能</li>
<li>本例中使用了文件通道FileChannel，是Channel的一种</li>
<li>FileChannel中的read和write方法通过操作Buffer达到读写文件的目的</li>
<li>Buffer的常用方法<ul>
<li>allocate：创建Buffer</li>
<li>clear：position置0，mark清空，limit设置为capacity，为重新写入Buffer做准备</li>
<li>flip：position置0，mark清空，limit设置为position，在读写切换时调用</li>
</ul>
</li>
</ul>
<p>Buffer是NIO中非常重要的一个类，我们会在后续的文章里说明它的基本原理和常用操作。</p>
<p><em>注：本文大部分内容摘自《Java程序性能优化》（清华大学出版社 葛一鸣 等编著）</em></p>
]]></content>
    <summary type="html"><![CDATA[<p>NIO是在JDK1.4引入的，代表New IO，具有以下特性：</p>
<ul>
<li>为所有的原始类型提供缓冲（Buffer）支持</li>
<li>使用Java.nio.charset.Charset作为字符集编解码解决方案</li>
<li>增加通道（Channel）对象，作为新的原始I/O抽象</li>
<li>支持锁和内存映射文件的文件访问接口</li>
<li>提供了基于Selector的异步网络IO</li>
</ul>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="NIO" scheme="http://hongbinzuo.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Enter i3]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/08/Enter-i3/"/>
    <id>http://hongbinzuo.github.io/2014/12/08/Enter-i3/</id>
    <published>2014-12-08T11:51:26.000Z</published>
    <updated>2014-12-08T12:35:08.000Z</updated>
    <content type="html"><![CDATA[<p>这几天Ubuntu系统特别慢，鉴于我之前Chrome浏览器经常干到50多个Tab，没事儿就开着IntelliJ和Eclipse的不良记录，我必须寻找更加节省内存、提高效率的方法。首先得反省自己，Chrome不能再开那么多Tab页面了，太吃内存了，最多开15个（^_^）。陈皓（@左耳朵耗子）前几天发了条微博说这事儿，但是Chrome还是得用，一是习惯了，二是还得用红杏插件。所以，我就想能不能让Ubuntu省点内存，于是，开始折腾。</p>
<a id="more"></a>

<p>查看任务管理器，发现Ubuntu自己的桌面管理器确实占用不少内存，于是到网上找解决方案，找来找去找到了<a href="http://xmonad.org/" target="_blank" rel="external">XMonad</a>，看起来很酷的感觉，赶紧装上重启，结果Bang！悲剧了～中间可能是我错误地执行了一条<code>startx</code>的命令，导致登录失败，于是网上搜索解决方案，坑吃坑吃总算解决了，结果XMonad不能用，瞬间脸都绿了，可能两三个小时过去了，我的人生啊～～piu！</p>
<p>今天早上醒来想想，难道XMonad这么麻烦吗？找了一会儿，发现了这篇神文：<a href="http://www.draconianoverlord.com/2014/05/26/from-xmonad-to-i3.html" target="_blank" rel="external">From XMonad to i3</a>。其中提到了XMonad在Ubuntu14.04中不能正常工作（正是我的场景啊），同时提到了另一个窗口布局解决方案：<a href="http://i3wm.org/" target="_blank" rel="external">i3</a>。比起XMonad，我更喜欢这个名字，i3，简约、不装，再看主页，不错，比XMonad那种纯Geek范儿更对我的胃口！搞起～</p>
<p>根据官方下载安装说明，一会儿就下载安装完成。重启，不用自己写配置文件，i3提示进行简略配置，大部分使用默认配置即可，这体验就一个字儿：舒服。找到常用的呼叫方法，比如<code>Mod</code>键（可以用<code>ALT</code>或<code>WIN</code>键，或加上<code>Shift</code>键）组合其他字母键呼叫操作系统功能，比如<code>Mod+D</code>呼叫系统命令，<code>Mod+Enter</code>呼叫终端，<code>Mod+Shift+Q</code>退出当前窗口等等。可以查看.i3/config文件查看KeyBindings，也可以打开i3的<a href="http://i3wm.org/docs/userguide.html#_default_keybindings" target="_blank" rel="external">UserGuide</a>边用边学，缺省的配置还配了一幅图，贴心。在Linux的世界里，能把极简主义和用户体验结合的这么好的工具，真不多见！</p>
<p>现在我可以用Emacs写博客，IntelliJ写程序，Chrome上网，这不算什么，关键是每个都可以放大到全屏，这种专注的感觉是传统的拖拉拽、窗口覆盖不能比的，所以你还不赶紧试试？XMonad不错，但是我现在更喜欢i3！继续体验中。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这几天Ubuntu系统特别慢，鉴于我之前Chrome浏览器经常干到50多个Tab，没事儿就开着IntelliJ和Eclipse的不良记录，我必须寻找更加节省内存、提高效率的方法。首先得反省自己，Chrome不能再开那么多Tab页面了，太吃内存了，最多开15个（^_^）。陈皓（@左耳朵耗子）前几天发了条微博说这事儿，但是Chrome还是得用，一是习惯了，二是还得用红杏插件。所以，我就想能不能让Ubuntu省点内存，于是，开始折腾。</p>
]]></summary>
    
      <category term="Linux" scheme="http://hongbinzuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WordCounter]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/08/WordCounter/"/>
    <id>http://hongbinzuo.github.io/2014/12/08/WordCounter/</id>
    <published>2014-12-08T11:28:05.000Z</published>
    <updated>2014-12-08T11:43:40.000Z</updated>
    <content type="html"><![CDATA[<p>题目：给出一个含有英文小说的文本文件，统计英文单词出现的频率并按照逆序打印。</p>
<p>完整实现如下：</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            List&lt;WordOccurrence&gt; list = WordCounter.doCount(<span class="string">"test.txt"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(WordOccurrence e:list)</div><div class="line">                System.out.println(e.word + <span class="string">":"</span>+ e.count);</div><div class="line"></div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * The word count container.</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> class WordOccurrence implements Comparable&lt;WordOccurrence&gt;{</div><div class="line">        String word;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="title">WordOccurrence</span>(String word, <span class="keyword">int</span> count){</div><div class="line">            <span class="keyword">this</span>.word = word;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="javadoc">/**</span></div><div class="line">         * sort in reverse order.</div><div class="line">         *<span class="javadoctag"> @param</span> o</div><div class="line">         *<span class="javadoctag"> @return</span></div><div class="line">         */</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(WordOccurrence o) {</div><div class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>.count &lt; o.count )</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>.count &gt; o.count )</div><div class="line">                <span class="keyword">return</span>  -<span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * Count the occurrences of each word, and sort them in descending order.</div><div class="line">     *<span class="javadoctag"> @param</span> fileName the name of the file to be parsed</div><div class="line">     *<span class="javadoctag"> @return</span> the word list in descending order of occurrence</div><div class="line">     *<span class="javadoctag"> @throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;WordOccurrence&gt; <span class="title">doCount</span>(String fileName) <span class="keyword">throws</span> IOException {</div><div class="line">        File file = <span class="keyword">new</span> File(fileName);</div><div class="line"></div><div class="line">        Reader fileReader = <span class="keyword">new</span> FileReader(file);</div><div class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</div><div class="line"></div><div class="line">        String line = <span class="keyword">null</span>;</div><div class="line">        Map&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// read into a hashmap first</span></div><div class="line">        <span class="keyword">while</span>( (line=bufferedReader.readLine())!= <span class="keyword">null</span>){</div><div class="line">            String[] words = line.split(Pattern.compile(<span class="string">"[ |,|.|!]"</span>).pattern());</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length ; i++) {</div><div class="line">                <span class="keyword">if</span> ( wordMap.containsKey(words[i])) {</div><div class="line">                    wordMap.put(words[i], wordMap.get(words[i]).intValue()+<span class="number">1</span>);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    wordMap.put(words[i], <span class="number">1</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// read into a list that can be sorted because element class(WordOccurrence) implements Comparable interface</span></div><div class="line">        List&lt;WordOccurrence&gt; wordList = <span class="keyword">new</span> ArrayList();</div><div class="line">        <span class="keyword">for</span>( Iterator iterator= wordMap.keySet().iterator();iterator.hasNext();){</div><div class="line">            String key = (String)iterator.next();</div><div class="line"></div><div class="line">            WordOccurrence wordOccurrence = <span class="keyword">new</span> WordOccurrence(key, wordMap.get(key).intValue());</div><div class="line">            wordList.add(wordOccurrence);</div><div class="line">        }</div><div class="line"></div><div class="line">        Collections.sort(wordList);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> wordList;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>题目：给出一个含有英文小说的文本文件，统计英文单词出现的频率并按照逆序打印。</p>
<p>完整实现如下：</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Performance difference for splitting strings]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/07/Performance-difference-for-splitting-strings/"/>
    <id>http://hongbinzuo.github.io/2014/12/07/Performance-difference-for-splitting-strings/</id>
    <published>2014-12-07T13:26:38.000Z</published>
    <updated>2014-12-07T14:21:37.000Z</updated>
    <content type="html"><![CDATA[<p>《Java程序性能优化》的3.1.3小节阐述了字符串分割的三种方法，并且用程序示例和图形说明了三种方法的性能差异。这三种方法分别是：split方法；使用StringTokenizer类；使用最原始的indexOf和substring方法。这三种方法的性能是依次增强的。但首先一个问题是：使用最后一种方法（本来应该是效率最高的）的例子试验时发现，这种方法却是最慢的，这是为什么呢？</p>
<a id="more"></a>

<p>书中的例子是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (int <span class="variable">i =</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</div><div class="line">    while(<span class="constant">true</span>){</div><div class="line">        String <span class="variable">splitStr =</span> <span class="constant">null</span>;</div><div class="line">        int <span class="variable">j =</span> tmp.indexOf(DELIMETER);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (j&lt;<span class="number">0</span>) break;</div><div class="line">        <span class="variable">splitStr =</span> tmp.substring(<span class="number">0</span>,j);</div><div class="line"></div><div class="line">        <span class="variable">tmp =</span> tmp.substring(j+<span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="variable">tmp =</span> myStr;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>很遗憾，上面的代码运行速度非常慢，最后只能修改循环次数为100才能勉强测试，最后运行时间是17632 ms。但是，indexOf和substring的方法真的这么慢吗？并非如此，书上的结论是正确的，只是给的例子不好，不能真正反映这个方法的性能。我们采用网上的另一个代码段来实现，结果截然不同：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int pos = 0, <span class="operator"><span class="keyword">end</span>;</span></div><div class="line">while ((<span class="operator"><span class="keyword">end</span> = tmp.indexOf(DELIMETER, pos)) &gt;= <span class="number">0</span>) {</span></div><div class="line">    <span class="keyword">String</span> splitStr = <span class="literal">null</span>;</div><div class="line">    splitStr = tmp.substring(pos, <span class="operator"><span class="keyword">end</span>);</span></div><div class="line">    pos = <span class="operator"><span class="keyword">end</span> + <span class="number">1</span>;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样循环100次，运行时间是119 ms，这个结果真的是让人惊呆了。仔细对比这两段代码，似乎只是多一个substring的调用而已，性能差距能有这么大吗？运行性能分析工具（如VisualVM），发现substring方法中的数组拷贝确实占用相当多的时间，<code>tmp = tmp.substring(j+1)</code>所产生的拷贝耗时在大字符串的情况下相当明显。</p>
<p>第二个问题，书中关于前两种方法的性能比较一定是正确的吗？按照SO上的例子（见参考资料），在我机器上的运行结果，并不是那么绝对：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">StringTokenizer took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">9.6</span> us</div><div class="line">Pattern.<span class="built_in">split</span> took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">7.0</span> us</div><div class="line">indexOf loop took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.1</span> us</div><div class="line">StringTokenizer took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.5</span> us</div><div class="line">Pattern.<span class="built_in">split</span> took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.3</span> us</div><div class="line">indexOf loop took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">2.4</span> us</div><div class="line">StringTokenizer took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.5</span> us</div><div class="line">Pattern.<span class="built_in">split</span> took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.4</span> us</div><div class="line">indexOf loop took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">2.3</span> us</div><div class="line">StringTokenizer took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.5</span> us</div><div class="line">Pattern.<span class="built_in">split</span> took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.4</span> us</div><div class="line">indexOf loop took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">2.4</span> us</div><div class="line">StringTokenizer took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.6</span> us</div><div class="line">Pattern.<span class="built_in">split</span> took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">4.5</span> us</div><div class="line">indexOf loop took <span class="operator">an</span> <span class="built_in">average</span> <span class="operator">of</span> <span class="number">2.4</span> us</div></pre></td></tr></table></figure>

<p>所以，你看到了，大部分情况下不是split慢，而是StringTokenizer慢，所以和书中描述的不符。不过另一个方面更有力的证据是在StringTokenizer类中官方的声明：不建议使用这个类，因为其中使用了老的Enumeration接口，建议使用split方法。所以结论是在性能要求不是特别高的情况下，我们使用split就好了。</p>
<p>最后，其实还有另一种方法性能比JDK的split更好，即Apache Commons的StringUtil的split方法，我没有做测试，感兴趣的同学可以自己试验一下。</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="http://stackoverflow.com/questions/5965767/performance-of-stringtokenizer-class-vs-split-method-in-java" target="_blank" rel="external">StackOverflow上非常好的示例</a></li>
<li><a href="http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html" target="_blank" rel="external">StringTokenizer类的Javadoc</a></li>
<li><a href="http://ben-sin.iteye.com/blog/659611" target="_blank" rel="external">关于split和indexOf的一个讨论</a></li>
<li><a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html" target="_blank" rel="external">Apache Commons的StringUtils类</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>《Java程序性能优化》的3.1.3小节阐述了字符串分割的三种方法，并且用程序示例和图形说明了三种方法的性能差异。这三种方法分别是：split方法；使用StringTokenizer类；使用最原始的indexOf和substring方法。这三种方法的性能是依次增强的。但首先一个问题是：使用最后一种方法（本来应该是效率最高的）的例子试验时发现，这种方法却是最慢的，这是为什么呢？</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[subString() no memory leak any more]]></title>
    <link href="http://hongbinzuo.github.io/2014/12/07/subString()-no-memory-leak-any-more/"/>
    <id>http://hongbinzuo.github.io/2014/12/07/subString()-no-memory-leak-any-more/</id>
    <published>2014-12-07T07:51:49.000Z</published>
    <updated>2014-12-07T08:11:43.000Z</updated>
    <content type="html"><![CDATA[<p>《Java程序性能优化》第三章Java程序优化首先讲的是字符串的特性及其相应的优化方法。3.1.2小节subString()方法的内存泄漏深入JDK的subString方法实现，并指出了大字符串对象可能存在的内存泄漏。我尝试把书中的程序段输入并运行，但结果并没有产生内存泄漏，原来情况有变。</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestSubString {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        List&lt;String&gt; handler = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> ; i++) {</div><div class="line">            HugeStr h = <span class="keyword">new</span> HugeStr();</div><div class="line">            <span class="comment">// ImprovedHugeStr h = new ImprovedHugeStr();</span></div><div class="line">            handler.add(h.getSubString(<span class="number">1</span>, <span class="number">5</span>));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> class HugeStr {</div><div class="line">        <span class="keyword">private</span> String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100000</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">public</span> String <span class="title">getSubString</span>(<span class="keyword">int</span> begin, <span class="keyword">int</span> end){</div><div class="line">            <span class="keyword">return</span> str.substring(begin, end);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> class ImprovedHugeStr{</div><div class="line">        <span class="keyword">private</span> String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100000</span>]);</div><div class="line">        <span class="keyword">public</span> String <span class="title">getSubString</span>(<span class="keyword">int</span> begin, <span class="keyword">int</span> end){</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(str.substring(begin, end));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考网上的几个回答之后，原来在JDK7u6之后，这个问题已经解掉了，所以在新的JDK版本中就不用担心subString的内存泄漏了。</p>
<p>附JDK7(build 1.7.0_72-b14)中String类subString方法的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String <span class="title">substring</span>(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex) {</div><div class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (endIndex &gt; <span class="keyword">value</span>.length) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</div><div class="line">        }</div><div class="line">        <span class="keyword">int</span> subLen = endIndex - beginIndex;</div><div class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) && (endIndex == <span class="keyword">value</span>.length)) ? <span class="keyword">this</span></div><div class="line">                : <span class="keyword">new</span> String(<span class="keyword">value</span>, beginIndex, subLen);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="http://stackoverflow.com/questions/15612157/substring-method-in-string-class-causes-memory-leak" target="_blank" rel="external">StackOverflow 问答1</a></li>
<li><a href="http://stackoverflow.com/questions/10951812/java-not-garbage-collecting-memory" target="_blank" rel="external">StackOverflow 问答2</a></li>
<li><a href="http://www.programcreek.com/2013/09/the-substring-method-in-jdk-6-and-jdk-7/" target="_blank" rel="external">带有插图的在JDK6和JDK7中subString不同实现的说明（推荐阅读）</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>《Java程序性能优化》第三章Java程序优化首先讲的是字符串的特性及其相应的优化方法。3.1.2小节subString()方法的内存泄漏深入JDK的subString方法实现，并指出了大字符串对象可能存在的内存泄漏。我尝试把书中的程序段输入并运行，但结果并没有产生内存泄漏，原来情况有变。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IoC/DI summary]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/18/IoCDI-summary/"/>
    <id>http://hongbinzuo.github.io/2014/11/18/IoCDI-summary/</id>
    <published>2014-11-17T16:15:35.000Z</published>
    <updated>2014-11-18T16:21:19.000Z</updated>
    <content type="html"><![CDATA[<p>下面的笔记根据Java私塾Spring公开视频教程整理并简化（你没看错，已经简化过了，^_^）。</p>
<h3 id="IoC/DI的基本思想">IoC/DI的基本思想</h3>
<ul>
<li>把程序之间的依赖关系去掉</li>
<li>把程序对象设置到IoC/DI容器的配置中，作为Bean</li>
<li>由IoC/DI容器（下面简称容器）来管理Bean的创建、实例化</li>
<li>由容器把Bean之间的关系注入到需要这些关系的对象里面</li>
</ul>
<a id="more"></a>

<p>简而言之，就是把对象之间的依赖关系全部去掉，然后由容器来管理对象之间的依赖关系。</p>
<h3 id="谁控制谁？">谁控制谁？</h3>
<ul>
<li>容器控制应用程序。</li>
</ul>
<h3 id="控制什么？">控制什么？</h3>
<ul>
<li>容器控制对象本身的创建、实例化。</li>
<li>容器控制对象之间的依赖关系。</li>
</ul>
<h3 id="为何叫反转？">为何叫反转？</h3>
<ul>
<li>因为应用程序不能主动获取外部资源了，而是被动等待容器注入它所需要的资源，所以称为反转。</li>
</ul>
<h3 id="哪些方面反转了？">哪些方面反转了？</h3>
<ul>
<li>创建对象</li>
<li>程序获得资源的方式</li>
</ul>
<h3 id="为何需要反转？">为何需要反转？</h3>
<ul>
<li>引入容器之后，体系更为松散，而且管理更加有序</li>
<li>类之间真正实现了松散耦合，使得开发、测试、维护、升级都变得容易了</li>
</ul>
<p>IoC/DI并没有帮助我们实现任何业务功能，原本该由应用实现的功能，还是应用自身完成。</p>
]]></content>
    <summary type="html"><![CDATA[<p>下面的笔记根据Java私塾Spring公开视频教程整理并简化（你没看错，已经简化过了，^_^）。</p>
<h3 id="IoC/DI的基本思想">IoC/DI的基本思想</h3>
<ul>
<li>把程序之间的依赖关系去掉</li>
<li>把程序对象设置到IoC/DI容器的配置中，作为Bean</li>
<li>由IoC/DI容器（下面简称容器）来管理Bean的创建、实例化</li>
<li>由容器把Bean之间的关系注入到需要这些关系的对象里面</li>
</ul>
]]></summary>
    
      <category term="DI" scheme="http://hongbinzuo.github.io/tags/DI/"/>
    
      <category term="IoC" scheme="http://hongbinzuo.github.io/tags/IoC/"/>
    
      <category term="Spring" scheme="http://hongbinzuo.github.io/tags/Spring/"/>
    
      <category term="Architecture" scheme="http://hongbinzuo.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Two ways of Sequence Printer implementation]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/17/Two-ways-of-Sequence-Printer-implementation/"/>
    <id>http://hongbinzuo.github.io/2014/11/17/Two-ways-of-Sequence-Printer-implementation/</id>
    <published>2014-11-17T15:29:36.000Z</published>
    <updated>2014-11-17T15:33:36.000Z</updated>
    <content type="html"><![CDATA[<p>题目：两个线程，分别打印[1,3,5]和[2,4,6]，写一个程序，打印[1,2,3,4,5,6]。<br>下面列出两种解法，分别用同步代码块和锁，具体参见程序。</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">package com.freelemon.concurrency.threads;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SeqPrinter1 {</div><div class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> boolean isThread1 = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">        SeqPrinter1 printer1 = <span class="keyword">new</span> SeqPrinter1();</div><div class="line">        printer1.printSequence();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSequence</span>() {</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                synchronized (obj){</div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">1</span>);</div><div class="line">                    isThread1 = <span class="keyword">false</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                    <span class="keyword">while</span> (!isThread1){</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            obj.wait();</div><div class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                            e.printStackTrace();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">3</span>);</div><div class="line">                    isThread1 = <span class="keyword">false</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                    <span class="keyword">while</span> (!isThread1){</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            obj.wait();</div><div class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                            e.printStackTrace();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">5</span>);</div><div class="line">                    isThread1 = <span class="keyword">false</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }, <span class="string">"Thread-1"</span>).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                synchronized (obj){</div><div class="line">                    <span class="keyword">while</span> (isThread1){</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            obj.wait();</div><div class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                            e.printStackTrace();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">2</span>);</div><div class="line">                    isThread1 = <span class="keyword">true</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                    <span class="keyword">while</span> (isThread1){</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            obj.wait();</div><div class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                            e.printStackTrace();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">4</span>);</div><div class="line">                    isThread1 = <span class="keyword">true</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                    <span class="keyword">while</span> (isThread1){</div><div class="line">                        <span class="keyword">try</span> {</div><div class="line">                            obj.wait();</div><div class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                            e.printStackTrace();</div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">6</span>);</div><div class="line">                    isThread1 = <span class="keyword">true</span>;</div><div class="line">                    obj.notify();</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }, <span class="string">"Thread-2"</span>).start();</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">package com.freelemon.concurrency.threads;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SeqPrinter2 {</div><div class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> Condition thread1Ready = <span class="keyword">lock</span>.newCondition();</div><div class="line">    <span class="keyword">private</span> Condition thread2Ready = <span class="keyword">lock</span>.newCondition();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">        SeqPrinter2 printer2 = <span class="keyword">new</span> SeqPrinter2();</div><div class="line">        printer2.printSequence();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSequence</span>(){</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                <span class="keyword">try</span>{</div><div class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line"></div><div class="line">                    thread1Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">1</span>);</div><div class="line"></div><div class="line">                    thread2Ready.signal();</div><div class="line">                    thread1Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">3</span>);</div><div class="line"></div><div class="line">                    thread2Ready.signal();</div><div class="line">                    thread1Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">5</span>);</div><div class="line"></div><div class="line">                    thread2Ready.signal();</div><div class="line">                    thread1Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                    e.printStackTrace();</div><div class="line">                } <span class="keyword">finally</span> {</div><div class="line">                    <span class="keyword">lock</span>.unlock();</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">            }</div><div class="line">        }, <span class="string">"Thread-1"</span>).start();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                <span class="keyword">try</span>{</div><div class="line">                    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line"></div><div class="line">                    thread1Ready.signal();</div><div class="line">                    thread2Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">2</span>);</div><div class="line"></div><div class="line">                    thread1Ready.signal();</div><div class="line">                    thread2Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">4</span>);</div><div class="line"></div><div class="line">                    thread1Ready.signal();</div><div class="line">                    thread2Ready.<span class="keyword">await</span>();</div><div class="line"></div><div class="line">                    System.<span class="keyword">out</span>.println(<span class="number">6</span>);</div><div class="line"></div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                    e.printStackTrace();</div><div class="line">                } <span class="keyword">finally</span> {</div><div class="line">                    <span class="keyword">lock</span>.unlock();</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">            }</div><div class="line">        }, <span class="string">"Thread-2"</span>).start();</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>题目：两个线程，分别打印[1,3,5]和[2,4,6]，写一个程序，打印[1,2,3,4,5,6]。<br>下面列出两种解法，分别用同步代码块和锁，具体参见程序。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SOAP vs. REST]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/16/SOAP-vs-REST/"/>
    <id>http://hongbinzuo.github.io/2014/11/16/SOAP-vs-REST/</id>
    <published>2014-11-16T06:46:58.000Z</published>
    <updated>2014-11-17T16:06:36.000Z</updated>
    <content type="html"><![CDATA[<p><em>译文，译自《软件构架实践（第3版 影印版）》。UPDATED: 2014-11-17</em></p>
<p>如果想让基于Web的应用进行互操作，目前有两种现成的技术可以选择：（1）WS*和SOAP（曾经代表“简单对象访问协议”，但这个缩写现在已经不再适用了）以及（2）REST（代表“表述性状态转移”，有时也写做ReST）。我们怎么看待这两种技术？每种技术都擅长什么？在使用的过程中有什么需要注意的地方？比较这两种技术似乎有点风马牛不相及，但我还是尝试着勾勒一下概貌。</p>
<a id="more"></a>

<p>SOAP是基于XML信息的一种协议规范，分布式应用可以通过它交换信息从而进行互操作。通常，SOAP有一组相对应的SOAP中间件互操作标准，以及兼容实现，（合在一起）叫做WS*。SOAP和WS*共同定义了许多标准，如下所示：</p>
<ul>
<li>服务组成的基础架构。开发者在SOAP中可以使用业务流程执行语言（BPEL）表示业务流程，这些都可以通过WS*服务来实现。</li>
<li>事务。为了确保正确地管理事务，定义了几种Web服务的标准：WS-AT，WS-BA，WS-CAF和WS-Transaction。</li>
<li>服务发现。通用服务发现和集成协议（UDDI）可以让企业发布服务列表并互相发现。</li>
<li>可靠性。SOAP本身并不保证消息的可靠送达。需要可靠性保证的应用必须使用符合SOAP可靠性标准即WS-Reliability的服务。</li>
</ul>
<p>SOAP非常通用，在远程过程调用（RPC）模型中应用很广，当然在其他模型中也可以使用。SOAP和主流编程语言相比，本身是一个简单类型系统。SOAP使用HTTP和RPC做消息传输，但其实从理论上来说，它可以在任何通信协议上实现。SOAP并不要求服务的方法命名、寻址模型或者过程规范。因此，选择SOAP并没有给应用之间的互操作带来太多的实际帮助——它只是一种信息交换标准。交互的双方要对如何解析负荷（payload）达成共识，只有这样才能获得语义互操作性。</p>
<p>另一方面，REST是基于客户端-服务器的架构风格，它是由一组CRUD（创建、读取、更新、删除）的操作（在REST的世界里，分别是POST，GET，PUT和DELETE）构成，并且只使用一种寻址方式（基于URI，或统一资源标识符）。REST在架构上加入了一些限制：SOAP提供了完整性；REST则提供了简单性。</p>
<p>REST是有关状态和状态转移的，它把Web（以及面向服务的系统能够组合在一起的服务）看作是一个巨大的信息网络，这些信息通过URI寻址的方式进行访问。所以，REST里没有类型的概念，当然也没有类型检查——完全取决于应用来确保交互语义的正确性。</p>
<p>因为REST接口如此简单并且具有一般性，任何HTTP客户端不需要额外的配置，都可以使用REST操作（POST, GET, PUT, DELETE）和任何HTTP服务器通信。这样你就获得了语法上的互操作能力，但是，这些程序实际上做什么以及交换什么信息都需要在组织层面上达成共识。也就是说，服务之间的语义互操作性只有REST接口是保证不了的。</p>
<p>REST基于HTTP，本身设计成自描述形式，在最好的情况下是无状态协议。下面考虑REST的一个例子，一个电话本服务，给定一个唯一标识符，可以查阅某个人：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">http:</span>/<span class="regexp">/www.XYZdirectory.com/phonebook</span><span class="regexp">/UserInfo/</span><span class="number">99999</span></div></pre></td></tr></table></figure>

<p>同样的一个查询，如果用SOAP来实现，可能会是这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">soap:Envelope</span> <span class="attribute">xmlns:soap</span>=<span class="value">http:</span>//<span class="attribute">www.w3.org</span>/<span class="attribute">2001</span>/<span class="attribute">12</span>/<span class="attribute">soap-envelope</span></span></div><div class="line"> <span class="attribute">soap:encodingStyle</span>=<span class="value">"http://www.w3.org/2001/12/soap-encoding"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="title">soap:Body</span> <span class="attribute">pb</span>=<span class="value">"http:///www.XYZdirectory.com/phonebook"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">pb:GetUserInfo</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">pb:UserIdentifier</span>&gt;</span>99999<span class="tag">&lt;/<span class="title">pb:UserIdentifier</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">pb:GetUserInfo</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">soap:Body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">soap:Envelope</span>&gt;</span></div></pre></td></tr></table></figure>

<p>选择SOAP还是REST的一个方面是你是否能接受SOAP+WSDL（Web服务描述语言）的复杂性和限制，从而得到更多的标准化互操作，或者使用REST从而避免额外的成本，标准更少但是也能获益。还有什么其他点需要考虑呢？</p>
<p>REST中的消息交换比SOAP中的消息交换携带更少的特征。所以在REST和SOAP之间的权衡之一便是各自的消息大小。对于需要交换大量消息的系统，另一个权衡点是性能（倾向于REST）还是结构化信息（倾向于SOAP）。</p>
<p>实现WS*或REST的决定取决于诸如需要的服务质量——WS*的实现对于安全、可用性等有更好的支持——以及功能类型等很多方面。RESTful的实现，由于其简单性，更加适合只读操作，典型是混搭（mashups）型的应用，而这些情境对于服务质量有最小的需求和担心。</p>
<p>好了，如果现在构建一个基于服务的系统，你会怎么选择？真实情况是，在整个过程中你不必只做一个选择；每种技术都相对易用，至少对于简单的应用来说。每种技术都有优势和弱势。就像在架构中的任何其他技术一样，最终都是权衡；你的决定很大程度上取决于在你的环境中那些权衡点如何影响你的系统。</p>
<p>——Rick Kazman</p>
<h3 id="学习REST的参考资料">学习REST的参考资料</h3>
<ul>
<li><a href="http://www.infoq.com/cn/articles/rest-introduction" target="_blank" rel="external">InfoQ上REST的介绍</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">Roy Fielding博士关于REST的原始论文</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p><em>译文，译自《软件构架实践（第3版 影印版）》。UPDATED: 2014-11-17</em></p>
<p>如果想让基于Web的应用进行互操作，目前有两种现成的技术可以选择：（1）WS*和SOAP（曾经代表“简单对象访问协议”，但这个缩写现在已经不再适用了）以及（2）REST（代表“表述性状态转移”，有时也写做ReST）。我们怎么看待这两种技术？每种技术都擅长什么？在使用的过程中有什么需要注意的地方？比较这两种技术似乎有点风马牛不相及，但我还是尝试着勾勒一下概貌。</p>
]]></summary>
    
      <category term="SOA" scheme="http://hongbinzuo.github.io/tags/SOA/"/>
    
      <category term="REST" scheme="http://hongbinzuo.github.io/tags/REST/"/>
    
      <category term="SOAP" scheme="http://hongbinzuo.github.io/tags/SOAP/"/>
    
      <category term="Architecture" scheme="http://hongbinzuo.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[synchronized and ReentrantLock]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/15/synchronized-and-ReentrantLock/"/>
    <id>http://hongbinzuo.github.io/2014/11/15/synchronized-and-ReentrantLock/</id>
    <published>2014-11-15T06:57:23.000Z</published>
    <updated>2014-11-15T07:19:39.000Z</updated>
    <content type="html"><![CDATA[<p>ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。ReentrantLock在性能上似乎优于内置锁，其中在Java 6中略有胜出，而在Java 5.0中则是远远胜出。那么为什么不放弃synchronized，并在所有新的并发代码中都使用ReentrantLock？事实上有些作者已经建议这么做，将synchronized作为一种“遗留”的结构，但这会将好事情变坏。</p>
<a id="more"></a>

<p>与显式锁相比，内置锁仍然具有很大的优势。内置锁为许多开发人员所熟悉，并且简洁紧凑，而且在许多现有的程序中都已经使用了内置锁——如果将这两种机制混合使用，那么不仅令人困惑，也容易发生错误。ReentrantLock的危险性比同步机制要高，如果忘记在finally块中调用unlock，那么虽然代码表面上能正常运行，但实际上已经埋下了一颗定时炸弹，并很有可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock。</p>
<p>…</p>
<p>未来更有可能提升synchronized而不是ReentrantLock的性能。因为synchronized是JVM的内置属性，它更会执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步，而如果通过基于类库的锁来实现这些功能，则可能性不大。除非将来需要在Java 5.0上部署应用程序，并且在该平台上确实需要ReentrantLock包含的可伸缩性，否则就性能方面来说，应该选择synchronized而不是ReentrantLock。</p>
<p>——《Java并发编程实战》</p>
]]></content>
    <summary type="html"><![CDATA[<p>ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。ReentrantLock在性能上似乎优于内置锁，其中在Java 6中略有胜出，而在Java 5.0中则是远远胜出。那么为什么不放弃synchronized，并在所有新的并发代码中都使用ReentrantLock？事实上有些作者已经建议这么做，将synchronized作为一种“遗留”的结构，但这会将好事情变坏。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lock() and lockInterruptibly()]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/15/lock()-and-lockInterruptibly()/"/>
    <id>http://hongbinzuo.github.io/2014/11/15/lock()-and-lockInterruptibly()/</id>
    <published>2014-11-15T06:21:33.000Z</published>
    <updated>2014-11-15T06:51:10.000Z</updated>
    <content type="html"><![CDATA[<p>在Lock接口中有两个方法，一个是lock方法，一个是lockInterruptibly方法，它们之间具体有什么区别呢？</p>
<blockquote>
<p>lock()是拿不到lock就不罢休，不然线程就一直block。lockInterruptibly会优先响应线程中断，处理响应的方式是抛出InterruptedException。</p>
</blockquote>
<p>可以参考一下 <a href="http://huangyunbin.iteye.com/blog/2013543" target="_blank" rel="external">http://huangyunbin.iteye.com/blog/2013543</a> ，我也大概看了一下lock和lockInterruptibly的相关源码，但是感觉原博说的有点不太对，不过因为现在没有太多时间深究，可以现从应用的角度来理解即可。原博中举的例子不错，这里就不重复引用了。</p>
]]></content>
    
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TryLock]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/15/TryLock/"/>
    <id>http://hongbinzuo.github.io/2014/11/15/TryLock/</id>
    <published>2014-11-15T04:13:26.000Z</published>
    <updated>2014-11-15T04:56:30.000Z</updated>
    <content type="html"><![CDATA[<p>《Java并发编程实战》这本书的缺点是有些例子给的不完整，所以想直接复制代码、运行看结果还是比较费力的，第13章显示锁的一个例子就是这样。在这种情况下，只能自己写或求助于互联网。下面用网上的一个小例子演示带有超时功能的tryLock的基本用法。关于Lock和同步代码块的区别以及更深入的研究，后续博文会有所涉及。</p>
<a id="more"></a>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.freelemon.concurrency.chp13;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Created with IntelliJ IDEA.</div><div class="line"> * User: hongbin</div><div class="line"> * Date: 14-11-15</div><div class="line"> * Time: 上午11:41</div><div class="line"> * To change this template use File | Settings | File Templates.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockingDemo</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="keyword">final</span> String... args){</div><div class="line">        <span class="keyword">new</span> ReentrantLockingDemo().go();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go</span>(){</div><div class="line">        <span class="keyword">new</span> Thread(newRunnable(), <span class="string">"Thread-1"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(newRunnable(), <span class="string">"Thread-2"</span>).start();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Runnable <span class="title">newRunnable</span>(){</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable(){</div><div class="line"></div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                do{</div><div class="line">                    <span class="keyword">try</span>{</div><div class="line">                        <span class="keyword">if</span> (lock.tryLock(<span class="number">500</span>, TimeUnit.MILLISECONDS)){</div><div class="line">                            <span class="keyword">try</span>{</div><div class="line">                                System.out.println(<span class="string">"Locked thread "</span> + Thread.currentThread().getName());</div><div class="line">                                Thread.sleep(<span class="number">1000</span>);</div><div class="line">                            } <span class="keyword">finally</span> {</div><div class="line">                                lock.unlock();</div><div class="line">                                    System.out.println(<span class="string">"unlocked locked thread "</span> + Thread.currentThread().getName());</div><div class="line">                            }</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            System.out.println(<span class="string">"unable to lock thread "</span> + Thread.currentThread().getName() + <span class="string">", will try again."</span>);</div><div class="line">                        }</div><div class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    }</div><div class="line"></div><div class="line">                } <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">            }</div><div class="line">        };</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Locked <span class="keyword">thread</span> <span class="keyword">Thread</span><span class="subst">-</span><span class="number">2</span></div><div class="line">unable <span class="keyword">to</span> lock <span class="keyword">thread</span> <span class="keyword">Thread</span><span class="subst">-</span><span class="number">1</span>, will try again<span class="built_in">.</span></div><div class="line">unlocked locked <span class="keyword">thread</span> <span class="keyword">Thread</span><span class="subst">-</span><span class="number">2</span></div><div class="line">Locked <span class="keyword">thread</span> <span class="keyword">Thread</span><span class="subst">-</span><span class="number">1</span></div><div class="line">unlocked locked <span class="keyword">thread</span> <span class="keyword">Thread</span><span class="subst">-</span><span class="number">1</span></div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ul>
<li>Credit属于 <a href="http://robaustin.wikidot.com/reentrantlock" target="_blank" rel="external">http://robaustin.wikidot.com/reentrantlock</a></li>
</ul>
<h3 id="PS">PS</h3>
<ul>
<li>上一篇谈到了CountDownLatch和CyclicBarrier，例子代码详见<a href="https://github.com/hongbinzuo/dojo/blob/master/src/com/freelemon/concurrency/countdownlatch/CountDownLatchTest.java" target="_blank" rel="external">https://github.com/hongbinzuo/dojo/blob/master/src/com/freelemon/concurrency/countdownlatch/CountDownLatchTest.java</a> 和 <a href="https://github.com/hongbinzuo/dojo/blob/master/src/com/freelemon/concurrency/cyclicbarrier/GameBarrier.java" target="_blank" rel="external">https://github.com/hongbinzuo/dojo/blob/master/src/com/freelemon/concurrency/cyclicbarrier/GameBarrier.java</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>《Java并发编程实战》这本书的缺点是有些例子给的不完整，所以想直接复制代码、运行看结果还是比较费力的，第13章显示锁的一个例子就是这样。在这种情况下，只能自己写或求助于互联网。下面用网上的一个小例子演示带有超时功能的tryLock的基本用法。关于Lock和同步代码块的区别以及更深入的研究，后续博文会有所涉及。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CountDownLatch and CyclicBarrier]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/09/CountDownLatch-and-CyclicBarrier/"/>
    <id>http://hongbinzuo.github.io/2014/11/09/CountDownLatch-and-CyclicBarrier/</id>
    <published>2014-11-09T15:38:59.000Z</published>
    <updated>2014-11-09T16:26:08.000Z</updated>
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier从字面上理解是“向下数的门闩”和“循环的障碍”，觉得怪怪的，但是即便翻译成更加书面语的“闭锁”或“栅栏”也并不容易理解。《Java并发编程实战》中详细讲解了两者的作用，也举了例子，但理解起来印象不深。如果只是从异同的角度去比较两者，网上倒是有不少文章，但是对于编程实践往往不如通俗的例子来得实在。</p>
<a id="more"></a>

<p>经过一番比较，发现<a href="http://blog.csdn.net/kuyuyingzi/article/details/19155697" target="_blank" rel="external">CSDN博客酷鱼影子</a>写的不错，下面摘录原博客的一些内容来解释这两者的适用场景。摘录内容略有修改，如果有版权问题，请作者告知。</p>
<p>— 摘录内容（例子参考原博文） —</p>
<p>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景，遇到这样的场景应该如何解决？如果是一个线程等待另一个线程，可以通过<code>wait()</code>和<code>notify()</code>来实现；如果是一个线程等待多个线程，那么可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</p>
<h3 id="CountDownLatch">CountDownLatch</h3>
<p>下面来详细描述CountDownLatch的应用场景：例如百米赛跑中8名运动员同时起跑，由于速度的快慢，肯定会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。其实这就是一个CountDownLatch的应用场景：一个线程（终点统计成绩的仪器）或多个线程<strong>等待其他线程</strong>（8名运动员）运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</p>
<p>那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</p>
<p>JDK中CountDownLatch类有一个常用的构造方法：<code>CountDownLatch(int count)</code>以及两个常用的方法：<code>await()</code>和<code>countdown()</code>。其中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了<code>countdown()</code>，则这个计数器就减一，当线程调用了<code>await()</code>，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程就继续自己下面的工作。</p>
<h3 id="CyclicBarrier">CyclicBarrier</h3>
<p>下面详细描述下CyclicBarrier的应用场景：有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说线程之间<strong>需要互相等待</strong>，这和CountDownLatch的应用场景有区别，CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情，而这里的线程需要等待其他线程后才能继续完成下面的工作。</p>
<p>JDK中CyclicBarrier类有两个常用的构造方法：</p>
<p> 1.<code>CyclicBarrier(int parties)</code></p>
<p>这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，注：这里parties里的计数在运行时当调用<code>CyclicBarrier:await()</code>时，计数就加1，一直加到初始的值。</p>
<p> 2.<code>CyclicBarrier(int parties, Runnable barrierAction)</code></p>
<p>这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个参数（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就执行barrierAction的内容。</p>
<p>— 摘录内容结束 —</p>
<p>其实细读一下Javadoc也是可以的，讲得也比较清楚：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="external">CountDownLatch的Javadoc</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="external">CylicBarrier的Javadoc</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier从字面上理解是“向下数的门闩”和“循环的障碍”，觉得怪怪的，但是即便翻译成更加书面语的“闭锁”或“栅栏”也并不容易理解。《Java并发编程实战》中详细讲解了两者的作用，也举了例子，但理解起来印象不深。如果只是从异同的角度去比较两者，网上倒是有不少文章，但是对于编程实践往往不如通俗的例子来得实在。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/08/ThreadLocal/"/>
    <id>http://hongbinzuo.github.io/2014/11/08/ThreadLocal/</id>
    <published>2014-11-08T03:56:59.000Z</published>
    <updated>2014-11-08T05:12:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。……在Swing中大量使用了线程封闭技术。……线程封闭技术的另一种常见应用是JDBC的Connection对象。</p>
<p>Java语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
</blockquote>
<a id="more"></a>

<p><strong>线程封闭</strong>的实现方式分为：</p>
<ul>
<li><strong>Ad-hoc线程封闭</strong>：完全由程序实现来确保线程封闭性，非常脆弱。</li>
<li><strong>栈封闭</strong>：局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问。比Ad-hoc更易于维护、更加健壮。需要注意的是基本类型的局部变量始终封闭在线程内（Java语言的语义保证），但是对象类型的局部变量则需要格外小心确保不会逸出。</li>
<li><strong>ThreadLocal类</strong>：这是维持线程封闭的规范方法。</li>
</ul>
<blockquote>
<p>这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因为get总是返回由当前执行线程在调用set时设置的最新值。</p>
</blockquote>
<p>下面是来自网上的一个例子，我稍微修改了一下，这样打印结果更容易理解：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</div><div class="line">        <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal =</div><div class="line">                <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">            <span class="keyword">int</span> myValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D);</div><div class="line">            System.out.println(Thread.currentThread().getName()</div><div class="line">                + <span class="string">": my value is set:"</span>+ myValue);</div><div class="line"></div><div class="line">            threadLocal.set(myValue);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">            }</div><div class="line"></div><div class="line">            System.out.println(Thread.currentThread().getName()</div><div class="line">                + <span class="string">": my value is:"</span>+ threadLocal.get());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</div><div class="line"></div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</div><div class="line"></div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span>: my <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">set</span>:<span class="number">95</span></div><div class="line">Thread-<span class="number">1</span>: my <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">set</span>:<span class="number">27</span></div><div class="line">Thread-<span class="number">1</span>: my <span class="keyword">value</span> <span class="keyword">is</span>:<span class="number">27</span></div><div class="line">Thread-<span class="number">0</span>: my <span class="keyword">value</span> <span class="keyword">is</span>:<span class="number">95</span></div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ul>
<li>文中引用部分摘自《Java并发编程实战》</li>
<li>例子代码来自：<a href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/threadlocal.html</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<blockquote>
<p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。……在Swing中大量使用了线程封闭技术。……线程封闭技术的另一种常见应用是JDBC的Connection对象。</p>
<p>Java语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
</blockquote>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Future]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/07/Future/"/>
    <id>http://hongbinzuo.github.io/2014/11/07/Future/</id>
    <published>2014-11-07T12:04:44.000Z</published>
    <updated>2014-11-07T13:17:38.000Z</updated>
    <content type="html"><![CDATA[<p>之前在看《Java程序员修炼之道》（主要讲的是Java 7的新特性）的时候就看过并发这块儿，但是感觉看完过段儿时间印象也有点儿模糊。最近重温Java并发编程，拿起了《Java并发编程实战》，只能用四个字儿来形容：干货太多。书里讲的几乎没有废话，大部分例子也都不错，对于理解新的Java并发编程模型很有帮助。不过，也有些例子可能受篇幅所限，讲解的不够细致，所以我就需要从网上再找些相对丰富的例子补充上以加深理解。Future就是其中一例。</p>
<a id="more"></a>

<p>下面的代码段摘自<a href="http://java.dzone.com/articles/javautilconcurrentfuture" target="_blank" rel="external">java.util.concurrent.Future Basics</a>，感觉这篇教程讲解虽然基础但是很清晰，看看代码基本上就理解Future的简单用法了。</p>
<h3 id="单线程应用">单线程应用</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public String downloadContents(URL url) throws IOException {</div><div class="line">    <span class="keyword">try</span>(InputStream input = url.openStream()) {</div><div class="line">        <span class="keyword">return</span> IOUtils.toString(input, StandardCharsets.UTF_8);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">//<span class="keyword">...</span></div><div class="line"></div><div class="line">final String contents = downloadContents(new URL(<span class="string">"http://www.example.com"</span>));</div></pre></td></tr></table></figure>

<h3 id="使用Future接口，并行处理">使用Future接口，并行处理</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static Future&lt;String&gt; startDownloading(URL url) {</div><div class="line">    //<span class="keyword">...</span></div><div class="line">}</div><div class="line"></div><div class="line">final Future&lt;String&gt; contentsFuture = startDownloading(new URL(<span class="string">"http://www.example.com"</span>));</div><div class="line">//other computation</div><div class="line">final String contents = contentsFuture.get();</div></pre></td></tr></table></figure>

<h3 id="调用isDone方法判断是否执行完成">调用isDone方法判断是否执行完成</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Future&lt;String&gt; contentsFuture = startDownloading(<span class="keyword">new</span> URL(<span class="string">"http://www.example.com"</span>));</div><div class="line"><span class="keyword">while</span> (!contentsFuture.isDone()) {</div><div class="line">    askUserToWait();</div><div class="line">    doSomeComputationInTheMeantime();</div><div class="line">}</div><div class="line">contentsFuture.<span class="keyword">get</span>();</div></pre></td></tr></table></figure>

<h3 id="取消任务">取消任务</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contentsFuture.<span class="built_in">cancel</span>(<span class="constant">true</span>);   <span class="comment"> //meh...</span></div></pre></td></tr></table></figure>

<h3 id="两种获得Future实例的方法">两种获得Future实例的方法</h3>
<h4 id="使用线程池">使用线程池</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">startDownloading</span>(<span class="keyword">final</span> URL url) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">return</span> pool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> String <span class="title">call</span>() <span class="keyword">throws</span> Exception {</div><div class="line">            <span class="keyword">try</span> (InputStream input = url.openStream()) {</div><div class="line">                <span class="keyword">return</span> IOUtils.toString(input, StandardCharsets.UTF_8);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="使用容器，如Spring或EJB">使用容器，如Spring或EJB</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Async</span></div><div class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">startDownloading</span>(<span class="keyword">final</span> URL url) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">try</span> (InputStream input = url.openStream()) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(</div><div class="line">                IOUtils.toString(input, StandardCharsets.UTF_8)</div><div class="line">        );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>代码实例能帮助理解，同时也要通读一下原文，注意其中的一些细节，比如超时和中断的处理逻辑等等。</p>
<p>最后，我们摘抄《Java并发实战》第7章的例子看看相对完整的一个取消操作是怎么完成的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> timedRun(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException {</div><div class="line">  Future&lt;?&gt; <span class="keyword">task</span> = taskExec.submit(r);</div><div class="line">  <span class="keyword">try</span> {</div><div class="line">    <span class="keyword">task</span>.get(timeout, unit);</div><div class="line">  } <span class="keyword">catch</span>(TimeoutException e) {</div><div class="line">    <span class="comment">// 接下来的任务将被取消</span></div><div class="line">  } <span class="keyword">catch</span>(ExecutionException e){</div><div class="line">    <span class="comment">// 如果在任务中抛出了异常，那么重新抛出异常</span></div><div class="line">    <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">  } <span class="keyword">finally</span> {</div><div class="line">    <span class="comment">// 如果任务已经结束，那么执行取消操作也不会带来任何影响</span></div><div class="line">    <span class="comment">// 如果任务正在运行，那么将被中断</span></div><div class="line">    <span class="keyword">task</span>.cancel(<span class="keyword">true</span>);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="参考资源">参考资源</h3>
<ul>
<li><a href="http://www.cnblogs.com/hanyuan/archive/2013/03/10/2952229.html" target="_blank" rel="external">http://www.cnblogs.com/hanyuan/archive/2013/03/10/2952229.html</a></li>
<li><a href="http://blog.csdn.net/lingchixin/article/details/38906849" target="_blank" rel="external">http://blog.csdn.net/lingchixin/article/details/38906849</a></li>
<li><a href="http://10kloc.wordpress.com/2013/12/24/cancelling-tasks-in-executors/" target="_blank" rel="external">http://10kloc.wordpress.com/2013/12/24/cancelling-tasks-in-executors/</a></li>
<li><a href="http://www.javacodegeeks.com/2011/09/java-concurrency-tutorial-callable.html" target="_blank" rel="external">http://www.javacodegeeks.com/2011/09/java-concurrency-tutorial-callable.html</a></li>
<li><a href="http://www.journaldev.com/1090/java-callable-future-example" target="_blank" rel="external">http://www.journaldev.com/1090/java-callable-future-example</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>之前在看《Java程序员修炼之道》（主要讲的是Java 7的新特性）的时候就看过并发这块儿，但是感觉看完过段儿时间印象也有点儿模糊。最近重温Java并发编程，拿起了《Java并发编程实战》，只能用四个字儿来形容：干货太多。书里讲的几乎没有废话，大部分例子也都不错，对于理解新的Java并发编程模型很有帮助。不过，也有些例子可能受篇幅所限，讲解的不够细致，所以我就需要从网上再找些相对丰富的例子补充上以加深理解。Future就是其中一例。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Concurrency" scheme="http://hongbinzuo.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate Object States]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/07/Hibernate-Object-States/"/>
    <id>http://hongbinzuo.github.io/2014/11/07/Hibernate-Object-States/</id>
    <published>2014-11-07T05:26:34.000Z</published>
    <updated>2014-11-07T06:20:38.000Z</updated>
    <content type="html"><![CDATA[<p>Hibernate是一种对象/关系映射的持久化框架，它做的主要工作之一就是对象和数据库表记录之间的状态管理。Hibernate编程环境中操作的对象指的是Entity POJO对象，它存在四种状态：Transient, Persistent, Detached和Removed。下面是从网上摘录的一幅图（源自Java Persistence with Hibernate这本书），非常好地说明了这几种状态之间的转换关系。</p>
<p><a id="more"></a><br><img alt="Hibernate对象状态转换图" src="/img/object-states.JPG" style="width: 750px;"></p>
<p>从这幅图中，我们可以看到，</p>
<ul>
<li>对象刚刚创建时是Transient（瞬时）状态，意味着和数据库没有任何关系，只在内存中存在</li>
<li>对象在保存或更新之后，进入Persistent（持久化）状态，此时数据库中已经有对象相应的记录，并生成了ID</li>
<li>当调用Session的clear等方法后，对象从Persistent进入Detached状态，此时Hibernate从<strong>缓存</strong>中将此对象清除，但在数据库中依然存在</li>
<li>Detached状态和Persistent状态可以相互转换，如图所示，如果保存更新对象，对象又从Detached状态进入Persistent状态</li>
<li>也可以通过load或get方法从数据库中获取该对象，从而直接进入Persistent状态</li>
<li>最后，调用Session的delete方法，对象就进入了不可逆转的Removed状态</li>
</ul>
<p>其实，这些状态变化还是比较符合常理的，所以只要了解基本原理，然后就可以写写代码验证即可。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="http://learningviacode.blogspot.com/2012/02/hibernate-object-life-cycle.html" target="_blank" rel="external">The Hibernate Object Life-Cycle</a></li>
<li><a href="http://www.roseindia.net/hibernate/HibernateLifeCycle.shtml" target="_blank" rel="external">Hibernate Life Cycle</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>Hibernate是一种对象/关系映射的持久化框架，它做的主要工作之一就是对象和数据库表记录之间的状态管理。Hibernate编程环境中操作的对象指的是Entity POJO对象，它存在四种状态：Transient, Persistent, Detached和Removed。下面是从网上摘录的一幅图（源自Java Persistence with Hibernate这本书），非常好地说明了这几种状态之间的转换关系。</p>
<p>]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="Hibernate" scheme="http://hongbinzuo.github.io/tags/Hibernate/"/>
    
      <category term="JavaEE" scheme="http://hongbinzuo.github.io/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A tip for Ubuntu 14.04 update]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/07/A-tip-for-Ubuntu-1404-update/"/>
    <id>http://hongbinzuo.github.io/2014/11/07/A-tip-for-Ubuntu-1404-update/</id>
    <published>2014-11-06T17:14:41.000Z</published>
    <updated>2014-11-06T17:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>安装了Ubuntu 14.04之后，出现一个小问题，软件自动更新时经常提示空间不足。搜一下，下面的链接提供了一些解决方案。<br><a href="http://askubuntu.com/questions/2793/how-do-i-remove-or-hide-old-kernel-versions-to-clean-up-the-boot-menu" target="_blank" rel="external">http://askubuntu.com/questions/2793/how-do-i-remove-or-hide-old-kernel-versions-to-clean-up-the-boot-menu</a></p>
<p>简单说想快速解决就是一条命令：<br><code>sudo apt-get remove --purge $(dpkg -l &#39;linux-image-*&#39; | sed &#39;/^ii/!d;/&#39;&quot;$(uname -r | sed &quot;s/\(.*\)-\([^0-9]\+\)/\1/&quot;)&quot;&#39;/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d&#39;)</code></p>
<p>这条命令会移除所有除了当前版本之外所有旧的Kernel安装包，以腾出空间。当然，如果想要彻底解决这个问题，可以参考上面的文章。</p>
]]></content>
    
    
      <category term="Ubuntu" scheme="http://hongbinzuo.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate Core API]]></title>
    <link href="http://hongbinzuo.github.io/2014/11/06/Hibernate-Core-API/"/>
    <id>http://hongbinzuo.github.io/2014/11/06/Hibernate-Core-API/</id>
    <published>2014-11-06T13:11:49.000Z</published>
    <updated>2014-11-06T17:12:44.000Z</updated>
    <content type="html"><![CDATA[<p>整理一下Hibernate核心API的笔记，感谢马老师。因为博客的发布形式，中间内容有些节略和修改。</p>
<h2 id="关于API文档">关于API文档</h2>
<p>因为Hibernate是属于JBoss的，按照JBoss的商业模式，文档和技术支持是收费的，所以官方不提供离线文档下载，只提供在线文档查看。当然，总有热心的网友看不过去，所以网上有非官方整理的API文档可供参考。</p>
<a id="more"></a>

<h2 id="Configuration">Configuration</h2>
<ul>
<li>AnnotationConfiguration 基于注解的配置</li>
<li>配置信息管理</li>
<li>用来产生SessionFactory</li>
<li>可以在configure方法中指定Hibernate配置文件</li>
<li>只关注一个方法即可：buildSessionFactory</li>
</ul>
<h2 id="SessionFactory">SessionFactory</h2>
<ul>
<li>用来产生和管理Session</li>
<li>通常情况下，每个应用只需要一个SessionFactory （单例），除非要访问多个数据库</li>
<li>关注两个方法即可<ul>
<li>openSession每次都是新的，需要close</li>
<li>getCurrentSession从上下文找，如果有，用已有的，否则，创建新的<ul>
<li>用途，界定事务边界</li>
<li>事务提交后自动close</li>
<li>上下文配置可参见XML文件中<code>current_session_context_classs</code>属性</li>
<li><code>current_session_context_classs</code>属性取值JTA和thread常用，managed和custom.class较少使用<ul>
<li>thread：使用Connection连接的数据库管理事务</li>
<li>JTA（Java Transaction API）：Java分布式事务管理（多数据库访问），JTA由中间件提供（JBoss、Weblogic等，Tomcat不支持）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Session">Session</h2>
<ul>
<li>管理一个数据库的任务单元（简单说就是增删改查），中文名为“会话”</li>
<li>方法（CRUD）<ul>
<li>Save <code>session.save(对象)</code></li>
<li>Delete <code>session.delete(对象)</code></li>
<li>Load <code>Student s1=(Student)session.load(Student.class, 1);</code></li>
<li>Get <code>Student s1=(Student)session.get(Student.class, 1);</code></li>
<li>Get与Load的区别（原理，面试重点）<ul>
<li>不存在对应记录时表现不一样</li>
<li>Load返回的是代理对象,等到真正用到对象内容时才发出SQL语句</li>
<li>Get直接从数据库加载不会延迟</li>
</ul>
</li>
<li>Update <code>session.update(对象)</code><ul>
<li>用来更新detached对象，更新完成后转为persistent</li>
<li>更新transient对象会报错</li>
<li>更新自己设定ID的transient对象可以（数据库有对应记录）</li>
<li>persistent状态的对象只要设定（如:t.setName…）不同字段就会更新</li>
<li>更新部分更改的字段<ul>
<li>XML配置文件中设定property标签的update属性，annotation设定 @Column 的 updatable属性，不过这种方式很少用，因为不灵活</li>
<li>使用XML中的dynamic-update，JPA1.0 Annotation 没有对应的属性，可能为Hibernate扩展</li>
<li>同一个session可以，跨session不行，不过可以用merge()(不重要）</li>
</ul>
</li>
<li>建议使用HQL(EJBQL)</li>
</ul>
</li>
<li>saveOrUpdate方法</li>
<li>clear方法<ul>
<li>无论是load还是get,都会首先査找缓存（一级缓存)，如果没有，才会去数据库査找，调用clear()方法可以强制清除session缓存</li>
</ul>
</li>
<li>flush方法<ul>
<li>当session的事务提交后,会强制将内存(session缓存)与数据库同步。默认情况下是session的事务提交(commit)时才同步!</li>
<li>session的FlushMode设置,可以设定在什么时候同步缓存与数据库(很少用)，例如: <code>session.setFlushMode(FlushMode.AUTO)</code></li>
</ul>
</li>
<li>find方法已过时</li>
</ul>
</li>
</ul>
<h2 id="SchemaExport_(自动建表)">SchemaExport (自动建表)</h2>
<ul>
<li>了解使用方法即可：<code>new SchemaExport(new AnnotationConfiguration().configure()).create(false, true);</code></li>
</ul>
<h2 id="查询接口">查询接口</h2>
<ul>
<li>参考Hibernate査询(HQL/EJBQL)的内容</li>
</ul>
<h2 id="注意">注意</h2>
<ul>
<li>Hibernate中涉及很多非常细节的区别,但在实际应用中用得极少<ul>
<li>比如save和persist的区别</li>
<li>merge、evict 等方法</li>
<li>比如 refresh、lock 等</li>
</ul>
</li>
<li>建议的学习方法，动手实验</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>整理一下Hibernate核心API的笔记，感谢马老师。因为博客的发布形式，中间内容有些节略和修改。</p>
<h2 id="关于API文档">关于API文档</h2>
<p>因为Hibernate是属于JBoss的，按照JBoss的商业模式，文档和技术支持是收费的，所以官方不提供离线文档下载，只提供在线文档查看。当然，总有热心的网友看不过去，所以网上有非官方整理的API文档可供参考。</p>
]]></summary>
    
      <category term="Java" scheme="http://hongbinzuo.github.io/tags/Java/"/>
    
      <category term="JavaEE" scheme="http://hongbinzuo.github.io/tags/JavaEE/"/>
    
      <category term="Hibernate" scheme="http://hongbinzuo.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top 8 free readings]]></title>
    <link href="http://hongbinzuo.github.io/2014/09/10/Top-8-free-readings/"/>
    <id>http://hongbinzuo.github.io/2014/09/10/Top-8-free-readings/</id>
    <published>2014-09-10T15:29:54.000Z</published>
    <updated>2014-09-10T17:13:28.000Z</updated>
    <content type="html"><![CDATA[<p>这是一个“信息大爆炸”的时代，在没有互联网的时候说这句话可能有人会怀疑，但是有了互联网之后大家都深信不疑。根据加州大学圣地亚哥分校的研究，一个典型的美国家庭在2008年平均收到3.6 ZB的信息，每人每天平均收到34 GB的信息，这只是2008年的研究结果，有人预测，每5年全世界的信息总量就会增加10倍。网络新闻、社交网络、邮箱、电视以及各种媒体每天都充斥你的左右，你是否也有信息焦虑症和选择困难症呢？</p>
<a id="more"></a>

<p>作为程序员，我们是天生的“学习者”，面对日新月异的新思想、新技术，我们主动或被动地获取相关的信息和知识以充实我们的大脑，完善自己的知识架构。信息技术领域变化飞快，这就要求我们能够高效地学习，如果只是盲目地在网络上左看右看，虽然能够找到有趣的内容，但难免会浪费很多时间，得不偿失。为了应对这个问题，下面列出8个适合程序员学习的聚合资源或垂直社区，可以帮助有效定位相关知识，大家各取所需吧（排名不分先后）。</p>
<h3 id="学习资源">学习资源</h3>
<h4 id="码农周刊">码农周刊</h4>
<p>由<a href="http://weibo.com/developerworks" target="_blank" rel="external">developerWorks</a>（微博帐号，应该不是IBM开发网络的官方帐号，只是名字碰巧相同）运营的码农周刊，可以通过邮件订阅，有时也发日报，个人觉得日报有点儿过头了，周刊都不一定能及时看完，推荐周刊。技术文章有分类，也有一些不影响阅读的广告和职位招聘信息。地址：<a href="http://weekly.manong.io/" target="_blank" rel="external">http://weekly.manong.io/</a></p>
<h4 id="Get新知社区">Get新知社区</h4>
<p>由<a href="http://weibo.com/easy" target="_blank" rel="external">Easy</a>（微博帐号）主导运营、新近才开张的一个学习型社区。个人感觉界面比较清新舒适，加上Easy本人技术能力过硬，推荐的资源（有些是他自己写的）一般比较靠谱。地址：<a href="http://get.jobdeer.com/" target="_blank" rel="external">http://get.jobdeer.com/</a></p>
<h4 id="Startup_News">Startup News</h4>
<p>由<a href="http://weibo.com/fenng" target="_blank" rel="external">Fenng</a>（丁香园CTO、小道消息出品人）运营的Startup News在程序员圈里也算小有名气，算是<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hackernews</a>的中国版吧，质量方面前一阵Fenng曾经整顿过，因为属于聚合资源，所以自己要有点鉴别能力。地址：<a href="http://news.dbanotes.net/" target="_blank" rel="external">http://news.dbanotes.net/</a></p>
<h4 id="好东西传送门">好东西传送门</h4>
<p>由<a href="http://weibo.com/xiguadawanzitang" target="_blank" rel="external">西瓜大丸子汤</a>（微博帐号）主导运营、也是新开张的在线收藏列表。界面上设计感不强，但也算流畅，博主本人也是技术牛人，所以质量方面还是可以保证的。地址：<a href="http://hao.memect.com/" target="_blank" rel="external">http://hao.memect.com/</a></p>
<h4 id="极客头条">极客头条</h4>
<p>由CSDN运营的极客头条，我自己看的不多，但毕竟是中国最大的程序员开发网络出品，呵呵，所以，还是要关注一下。地址：<a href="http://geek.csdn.net/" target="_blank" rel="external">http://geek.csdn.net/</a></p>
<h4 id="《架构师》期刊">《架构师》期刊</h4>
<p>Infoq官方出品，有深度、有广度、干货多，不容易消化，一般都不是入门级教程，95后年轻程序员慎入。地址：<a href="http://www.infoq.com/cn/architect/" target="_blank" rel="external">http://www.infoq.com/cn/architect/</a></p>
<h4 id="《码农》期刊">《码农》期刊</h4>
<p>相比《架构师》，《码农》这个名字有点自嘲的意思，有的猿媛不喜欢这个称呼，认为有点自轻自贱，其实认真你就输了。推荐你听一下Beyond的<a href="http://music.163.com/#/song?id=347502" target="_blank" rel="external">《农民》</a>，也许你感觉就不一样了。地址：<a href="http://www.ituring.com.cn/book/tagged/1735" target="_blank" rel="external">http://www.ituring.com.cn/book/tagged/1735</a></p>
<h4 id="《编程狂人》期刊">《编程狂人》期刊</h4>
<p>推酷推出的期刊，我没有仔细看过，等我看完之后补一点感受，第一印象还可以。地址：<a href="http://www.tuicool.com/mags" target="_blank" rel="external">http://www.tuicool.com/mags</a></p>
<h3 id="Bonus">Bonus</h3>
<h4 id="Ourcoders">Ourcoders</h4>
<p>由tiny叔（大家都这么叫）运营的“我们是猿媛”是程序员的交流社区，无聊或苦闷的时候上去聊聊吧：<a href="http://ourcoders.com/home/" target="_blank" rel="external">http://ourcoders.com/home/</a></p>
<h4 id="v2ex">v2ex</h4>
<p>Way to explore，也是一个交流社区，挺好玩的，学习枯燥的时候上去扯一扯愉悦身心：<a href="http://v2ex.com" target="_blank" rel="external">http://v2ex.com</a></p>
<h3 id="后记">后记</h3>
<p>这篇文章主要是收集一些中文的轻量级学习资源，虽说是轻量级，如果学习没有方向和重点也是“乱花渐欲迷人眼”，所以还是要找准方向，专注而后精进，才能学有小成。祝大家学习愉快！</p>
<h3 id="参考资源">参考资源</h3>
<ul>
<li><a href="http://blog.sciencenet.cn/blog-50350-301466.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-50350-301466.html</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>这是一个“信息大爆炸”的时代，在没有互联网的时候说这句话可能有人会怀疑，但是有了互联网之后大家都深信不疑。根据加州大学圣地亚哥分校的研究，一个典型的美国家庭在2008年平均收到3.6 ZB的信息，每人每天平均收到34 GB的信息，这只是2008年的研究结果，有人预测，每5年全世界的信息总量就会增加10倍。网络新闻、社交网络、邮箱、电视以及各种媒体每天都充斥你的左右，你是否也有信息焦虑症和选择困难症呢？</p>
]]></summary>
    
      <category term="learning" scheme="http://hongbinzuo.github.io/tags/learning/"/>
    
      <category term="reading" scheme="http://hongbinzuo.github.io/tags/reading/"/>
    
  </entry>
  
</feed>
